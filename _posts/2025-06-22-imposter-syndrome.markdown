---
layout: post
title:  "I Built An App With AI, and I'm Not Sure I'm a 'Real' Developer"
date:   2025-06-23 06:48:00 -0500
categories: development cursorai python pyqt6 navidrome
---

I just finished building a project I'm incredibly proud of. It’s Pyper, a feature-rich, Linux-first desktop music player for Navidrome servers. It has a powerful search, an advanced internet radio streamer, a comprehensive theming system, and a slick, modern UI built with PyQt6. I used Cursor, an AI-powered code editor, for the entire process. I love what I built. I love the process of building it.

And I feel like a complete and total fraud.

This feeling—that I haven't earned the right to be proud of my work—is a specific flavor of imposter syndrome that I suspect is becoming more common. It stems from a simple, nagging thought: *I didn't actually write the code.*

I had the idea, I prompted the AI, I stitched the pieces together, and I debugged the inevitable (and numerous) errors. But line-for-line, character-for-character? I can't claim authorship. And in the world of software development, that feels like a cardinal sin.

### The Two Cultures: Code as Craft vs. Code as a Tool

My struggle comes from a deep-seated reverence for those who "code" in the traditional sense. These are the people who have a profound, intimate knowledge of a programming language. They can debate the merits of different UI frameworks, write elegant, idiomatic Python, and solve complex algorithms from memory. Their identity is often intertwined with their chosen language. This is the culture of **Code as Craft**.

I have massive respect for these artisans. Their work pushes the entire field forward. But I am not one of them.

I come from the world of data analytics. In my field, no one’s identity is "I'm a DAX professional." No one worships at the altar of SQL. They are tools. They are a means to an end. The goal is the analysis, the insight, the final report. This is the culture of **Code as a Tool**.

That’s how I see Pyper. I didn't fall in love with PyQt6's syntax; I fell in love with what it allowed me to build. The AI was the ultimate tool that let me translate my vision into a functional product—something I could never have done on my own.

### My Role Was Architect, Not Typist

So if the AI was the coder, what was I? After wrestling with this, I've landed on an answer: I was the architect, the system integrator, and the domain expert. An AI can generate a function, but it cannot understand a problem.

The AI didn't:
-   **Assemble the required knowledge.** It didn't know how to set up a Navidrome server on a Raspberry Pi, learn its specific APIs, or understand the nuances of its SQLite database structure. I had to do that.
-   **Design for a specific user.** This app was built for me. The AI couldn't anticipate my personal requirements or design a workflow perfectly tailored to how I listen to music.
-   **Architect the complete user experience.** It didn't invent the seven-tab interface, design the "Go to..." context menus for smart navigation, or decide on a responsive 3-column visual grid for albums.
-   **Devise complex, multi-step solutions.** It didn't create the fallback strategy for fetching album art (first MusicBrainz, then iTunes), or come up with the plan for remote database access over SSH to pull play-count data.
-   **Specify the core features.** It couldn't conceptualize an advanced radio streamer with real-time metadata parsing or a comprehensive theming system with automatic text contrast.
-   **Integrate and debug the whole system.** The AI generated code in pieces. My job was to make them all work together and solve the inevitable errors that arose from that complex integration.

My contribution wasn't typing; it was understanding, planning, and problem-solving.

### Where Do I Go From Here?

This realization helps, but it doesn't solve the core problem of validation. Where do people like me fit in? As a budding developer using AI, I exist in a strange no-man's-land. I don't feel like I belong in the "Code as Craft" culture, because I can't discuss the nuances of the language. But I'm also not a traditional "builder" who has the years of experience to prove their worth.

I don't have a clear answer yet. Perhaps the validation isn't something I can ask for, but something I have to claim. It lives in the finished product—in this complex, feature-rich application that does exactly what I designed it to do. It lives in the detailed README I wrote to share it with the world.

Ultimately, the measure of success is that a complex problem was solved and a useful tool was created. My job was to be the expert on the problem; the AI was the expert on the syntax. That partnership resulted in a real, working application. Is that cheating, or is it just the future of building things? I'm still not sure.